"""
Directory Scanner Module - Dirb and Gobuster Integration
"""

import json
import re
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path
from urllib.parse import urljoin, urlparse

from src.core import ScannerBase, ScanResult, ScanStatus, ScanSeverity
from src.core import CommandExecutor, validate_url, validate_domain, validate_ip
from src.utils.logger import log_info, log_error, log_warning


class DirectoryScanner(ScannerBase):
    """
    Directory and file scanner using dirb and gobuster
    """

    def __init__(self, timeout: int = 300):
        """
        Initialize directory scanner

        Args:
            timeout: Scan timeout in seconds
        """
        super().__init__("directory_scanner", timeout=timeout)
        self.executor = CommandExecutor(timeout=self.timeout)

        # Default wordlists (system paths)
        self.wordlists = {
            "small": "/usr/share/wordlists/dirb/small.txt",
            "common": "/usr/share/wordlists/dirb/common.txt",
            "big": "/usr/share/wordlists/dirb/big.txt",
            "gobuster_common": "/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt",
            "gobuster_medium": "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt",
        }

        # File extensions to test
        self.file_extensions = [
            "php",
            "asp",
            "aspx",
            "jsp",
            "html",
            "htm",
            "txt",
            "pdf",
            "xml",
            "js",
            "css",
            "json",
            "backup",
            "bak",
            "old",
            "config",
            "conf",
        ]

        # Interesting paths patterns
        self.interesting_patterns = [
            "admin",
            "login",
            "upload",
            "backup",
            "config",
            "test",
            "dev",
            "staging",
            "api",
            "v1",
            "v2",
            "private",
            "secret",
            "hidden",
            ".git",
            ".svn",
        ]

    def validate_target(self, target: str) -> bool:
        """
        Validate if target is appropriate for directory scanning

        Args:
            target: Target URL, domain, or IP

        Returns:
            bool: True if valid target, False otherwise
        """
        # Accept URLs directly
        if target.startswith(("http://", "https://")):
            return validate_url(target)

        # Accept domains and IPs (will be converted to URLs)
        return validate_domain(target) or validate_ip(target)

    def _execute_scan(self, target: str, options: Dict[str, Any]) -> ScanResult:
        """
        Execute directory scanning

        Args:
            target: Target to scan
            options: Scan options

        Returns:
            ScanResult: Parsed scan results
        """
        result = ScanResult(
            scanner_name=self.name,
            target=target,
            status=ScanStatus.RUNNING,
            start_time=datetime.now(),
        )

        try:
            # Normalize target to URL
            target_url = self._normalize_target_url(target, options)
            result.target = target_url

            self.logger.info(f"Starting directory scan on: {target_url}")

            # Choose scanner tool
            preferred_tool = options.get("tool", "auto")
            tool = self._select_scanner_tool(preferred_tool)

            if not tool:
                result.errors.append(
                    "No directory scanning tool available (dirb or gobuster)"
                )
                result.status = ScanStatus.FAILED
                return result

            result.metadata["tool_used"] = tool

            # Execute scan based on tool
            if tool == "dirb":
                self._run_dirb_scan(target_url, options, result)
            elif tool == "gobuster":
                self._run_gobuster_scan(target_url, options, result)

            result.status = ScanStatus.COMPLETED
            self.logger.info(
                f"Directory scan completed. Found {len(result.findings)} items"
            )

        except Exception as e:
            result.status = ScanStatus.FAILED
            result.errors.append(f"Directory scan failed: {str(e)}")
            self.logger.error(f"Directory scan error: {e}")

        return result

    def _normalize_target_url(self, target: str, options: Dict[str, Any]) -> str:
        """
        Normalize target to proper URL format

        Args:
            target: Target string
            options: Scan options

        Returns:
            str: Normalized URL
        """
        if target.startswith(("http://", "https://")):
            return target

        scheme = options.get("scheme", "https")
        port = options.get("port")

        if port:
            return f"{scheme}://{target}:{port}"
        else:
            return f"{scheme}://{target}"

    def _select_scanner_tool(self, preferred: str) -> Optional[str]:
        """
        Select available directory scanner tool

        Args:
            preferred: Preferred tool ('dirb', 'gobuster', 'auto')

        Returns:
            Optional[str]: Selected tool name or None
        """
        if preferred == "dirb" and self.executor.check_tool_exists("dirb"):
            return "dirb"
        elif preferred == "gobuster" and self.executor.check_tool_exists("gobuster"):
            return "gobuster"
        elif preferred == "auto":
            # Auto-select: prefer gobuster if available, fallback to dirb
            if self.executor.check_tool_exists("gobuster"):
                return "gobuster"
            elif self.executor.check_tool_exists("dirb"):
                return "dirb"

        return None

    def _run_dirb_scan(
        self, url: str, options: Dict[str, Any], result: ScanResult
    ) -> None:
        """
        Run dirb directory scan

        Args:
            url: Target URL
            options: Scan options
            result: ScanResult to populate
        """
        try:
            # Select wordlist
            wordlist = self._get_wordlist(options.get("wordlist", "common"))

            # Build dirb command
            dirb_cmd = [
                "dirb",
                url,
                wordlist,
                "-w",  # Don't stop on warnings
                "-r",  # Don't search recursively
            ]

            # Add file extensions if requested
            if options.get("extensions", True):
                extensions = options.get(
                    "extension_list", self.file_extensions[:8]
                )  # First 8
                ext_string = ",".join(extensions)
                dirb_cmd.extend(["-X", ext_string])

            # Custom user agent
            if options.get("user_agent"):
                dirb_cmd.extend(["-a", options["user_agent"]])

            # Output to file for parsing
            dirb_cmd.extend(["-o", "/dev/stdout"])

            self.logger.info(f"Running dirb: {' '.join(dirb_cmd[:4])}")
            result.metadata["dirb_command"] = " ".join(dirb_cmd)

            # Execute dirb
            dirb_result = self.executor.execute(dirb_cmd, timeout=self.timeout)
            result.metadata["dirb_execution_time"] = dirb_result.execution_time
            result.metadata["dirb_return_code"] = dirb_result.return_code

            if dirb_result.success:
                self._parse_dirb_output(dirb_result.stdout, url, result)
            else:
                result.errors.append(f"Dirb scan failed: {dirb_result.stderr}")
                self.logger.error(f"Dirb failed: {dirb_result.stderr}")

        except Exception as e:
            result.errors.append(f"Dirb scan error: {str(e)}")
            self.logger.error(f"Dirb error: {e}")

    def _run_gobuster_scan(
        self, url: str, options: Dict[str, Any], result: ScanResult
    ) -> None:
        """
        Run gobuster directory scan

        Args:
            url: Target URL
            options: Scan options
            result: ScanResult to populate
        """
        try:
            # Select wordlist
            wordlist = self._get_wordlist(options.get("wordlist", "gobuster_common"))

            # Build gobuster command
            gobuster_cmd = [
                "gobuster",
                "dir",
                "-u",
                url,
                "-w",
                wordlist,
                "-t",
                str(options.get("threads", 10)),  # Threads
                "-q",  # Quiet mode
                "--no-error",  # Don't display errors
            ]

            # Add file extensions if requested
            if options.get("extensions", True):
                extensions = options.get("extension_list", self.file_extensions[:8])
                ext_string = ",".join(extensions)
                gobuster_cmd.extend(["-x", ext_string])

            # Status codes to include
            status_codes = options.get("status_codes", "200,204,301,302,307,401,403")
            gobuster_cmd.extend(["-s", status_codes])

            # Custom user agent
            if options.get("user_agent"):
                gobuster_cmd.extend(["-a", options["user_agent"]])

            self.logger.info(f"Running gobuster: {' '.join(gobuster_cmd[:6])}")
            result.metadata["gobuster_command"] = " ".join(gobuster_cmd)

            # Execute gobuster
            gobuster_result = self.executor.execute(gobuster_cmd, timeout=self.timeout)
            result.metadata["gobuster_execution_time"] = gobuster_result.execution_time
            result.metadata["gobuster_return_code"] = gobuster_result.return_code

            if gobuster_result.success:
                self._parse_gobuster_output(gobuster_result.stdout, url, result)
            else:
                result.errors.append(f"Gobuster scan failed: {gobuster_result.stderr}")
                self.logger.error(f"Gobuster failed: {gobuster_result.stderr}")

        except Exception as e:
            result.errors.append(f"Gobuster scan error: {str(e)}")
            self.logger.error(f"Gobuster error: {e}")

    def _get_wordlist(self, wordlist_spec: str) -> str:
        """
        Get wordlist path based on specification

        Args:
            wordlist_spec: Wordlist specification

        Returns:
            str: Path to wordlist file
        """
        # If it's a direct path, use it
        if wordlist_spec.startswith("/") or Path(wordlist_spec).exists():
            return wordlist_spec

        # If it's a predefined wordlist name
        if wordlist_spec in self.wordlists:
            wordlist_path = self.wordlists[wordlist_spec]
            if Path(wordlist_path).exists():
                return wordlist_path

        # Fallback to common wordlist
        fallback_paths = [
            "/usr/share/wordlists/dirb/common.txt",
            "/usr/share/dirb/wordlists/common.txt",
            "/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt",
        ]

        for path in fallback_paths:
            if Path(path).exists():
                return path

        # If no wordlist found, create a minimal one
        self.logger.warning("No wordlist found, using minimal built-in list")
        return self._create_minimal_wordlist()

    def _create_minimal_wordlist(self) -> str:
        """Create a minimal wordlist file"""
        minimal_words = [
            "admin",
            "login",
            "upload",
            "backup",
            "config",
            "test",
            "dev",
            "api",
            "data",
            "files",
            "images",
            "js",
            "css",
            "assets",
            "include",
            "inc",
            "tmp",
        ]

        temp_file = Path("/tmp/auto_pentest_minimal_wordlist.txt")
        with open(temp_file, "w") as f:
            for word in minimal_words:
                f.write(f"{word}\n")

        return str(temp_file)

    def _parse_dirb_output(
        self, dirb_output: str, base_url: str, result: ScanResult
    ) -> None:
        """
        Parse dirb output

        Args:
            dirb_output: Raw dirb output
            base_url: Base URL being scanned
            result: ScanResult to populate
        """
        try:
            lines = dirb_output.strip().split("\n")
            found_count = 0

            for line in lines:
                line = line.strip()

                # Look for found directories/files
                # Dirb format: "==> DIRECTORY: http://example.com/admin/"
                # Dirb format: "+ http://example.com/login.php (CODE:200|SIZE:1234)"

                if line.startswith("==> DIRECTORY:"):
                    directory = line.split("DIRECTORY: ")[1].strip()
                    self._process_found_item(directory, "directory", "200", "0", result)
                    found_count += 1

                elif line.startswith("+ ") and "(CODE:" in line:
                    # Parse file finding
                    url_part = line.split(" ")[1]
                    info_part = line.split("(")[1].rstrip(")")

                    # Extract status code and size
                    status_code = "200"
                    size = "0"

                    if "CODE:" in info_part:
                        status_code = info_part.split("CODE:")[1].split("|")[0]
                    if "SIZE:" in info_part:
                        size = info_part.split("SIZE:")[1].split("|")[0]

                    self._process_found_item(
                        url_part, "file", status_code, size, result
                    )
                    found_count += 1

            result.metadata["dirb_items_found"] = found_count
            self.logger.info(f"Dirb found {found_count} items")

        except Exception as e:
            result.errors.append(f"Dirb output parsing failed: {str(e)}")
            self.logger.error(f"Dirb parsing error: {e}")

    def _parse_gobuster_output(
        self, gobuster_output: str, base_url: str, result: ScanResult
    ) -> None:
        """
        Parse gobuster output

        Args:
            gobuster_output: Raw gobuster output
            base_url: Base URL being scanned
            result: ScanResult to populate
        """
        try:
            lines = gobuster_output.strip().split("\n")
            found_count = 0

            for line in lines:
                line = line.strip()

                # Gobuster format: "/admin (Status: 200) [Size: 1234]"
                if line and not line.startswith("="):
                    match = re.match(
                        r"^([^\s]+)\s+\(Status:\s+(\d+)\)\s+\[Size:\s+(\d+)\]", line
                    )
                    if match:
                        path = match.group(1)
                        status_code = match.group(2)
                        size = match.group(3)

                        # Build full URL
                        full_url = urljoin(base_url, path)

                        # Determine if it's a directory or file
                        item_type = "directory" if path.endswith("/") else "file"

                        self._process_found_item(
                            full_url, item_type, status_code, size, result
                        )
                        found_count += 1

            result.metadata["gobuster_items_found"] = found_count
            self.logger.info(f"Gobuster found {found_count} items")

        except Exception as e:
            result.errors.append(f"Gobuster output parsing failed: {str(e)}")
            self.logger.error(f"Gobuster parsing error: {e}")

    def _process_found_item(
        self, url: str, item_type: str, status_code: str, size: str, result: ScanResult
    ) -> None:
        """
        Process a found directory or file

        Args:
            url: Found URL
            item_type: 'directory' or 'file'
            status_code: HTTP status code
            size: Response size
            result: ScanResult to populate
        """
        try:
            # Extract path from URL
            parsed = urlparse(url)
            path = parsed.path

            # Determine severity based on path content
            severity = self._determine_path_severity(path)

            # Check if path is interesting
            is_interesting = any(
                pattern in path.lower() for pattern in self.interesting_patterns
            )

            # Create title
            title = f"Found {item_type.title()}: {path}"
            if is_interesting:
                title = f"Interesting {item_type.title()}: {path}"

            # Create description
            description = (
                f"Found {item_type} at {path} (Status: {status_code}, Size: {size})"
            )
            if is_interesting:
                description = f"Potentially interesting {item_type} found: {path}"

            # Create finding
            result.add_finding(
                title=title,
                description=description,
                severity=severity,
                category=f"directory_{item_type}",
                url=url,
                path=path,
                status_code=int(status_code) if status_code.isdigit() else 0,
                size=int(size) if size.isdigit() else 0,
                item_type=item_type,
                is_interesting=is_interesting,
                details={
                    "url": url,
                    "path": path,
                    "status_code": status_code,
                    "size": size,
                    "type": item_type,
                    "interesting": is_interesting,
                },
            )

        except Exception as e:
            self.logger.debug(f"Error processing found item {url}: {e}")

    def _determine_path_severity(self, path: str) -> ScanSeverity:
        """
        Determine severity based on path content

        Args:
            path: URL path

        Returns:
            ScanSeverity: Severity level
        """
        path_lower = path.lower()

        # High severity - admin/config areas
        high_patterns = [
            "admin",
            "login",
            "config",
            "backup",
            ".git",
            ".svn",
            "private",
        ]
        if any(pattern in path_lower for pattern in high_patterns):
            return ScanSeverity.HIGH

        # Medium severity - development/test areas
        medium_patterns = ["test", "dev", "staging", "debug", "upload", "tmp"]
        if any(pattern in path_lower for pattern in medium_patterns):
            return ScanSeverity.MEDIUM

        # Low severity - informational
        low_patterns = ["api", "docs", "help", "info"]
        if any(pattern in path_lower for pattern in low_patterns):
            return ScanSeverity.LOW

        # Default to info
        return ScanSeverity.INFO

    def get_capabilities(self) -> Dict[str, Any]:
        """
        Get scanner capabilities

        Returns:
            Dict: Scanner capabilities and information
        """
        # Check for required tools
        dirb_available = self.executor.check_tool_exists("dirb")
        gobuster_available = self.executor.check_tool_exists("gobuster")

        dirb_version = (
            self.executor.get_tool_version("dirb") if dirb_available else None
        )
        gobuster_version = (
            self.executor.get_tool_version("gobuster", "-h")
            if gobuster_available
            else None
        )

        return {
            "name": self.name,
            "description": "Directory and file enumeration scanner",
            "version": "1.0.0",
            "supported_targets": ["url", "domain", "ip"],
            "scan_types": ["directory", "file", "recursive"],
            "tools": ["dirb", "gobuster"],
            "timeout": self.timeout,
            "dependencies": {
                "dirb": {
                    "required": False,
                    "version": dirb_version,
                    "available": dirb_available,
                },
                "gobuster": {
                    "required": False,
                    "version": gobuster_version,
                    "available": gobuster_available,
                },
            },
            "options": {
                "tool": "Scanner tool to use (dirb, gobuster, auto)",
                "wordlist": "Wordlist to use (small, common, big, custom path)",
                "extensions": "Include file extensions",
                "extension_list": "Custom extension list",
                "threads": "Number of threads (gobuster only)",
                "status_codes": "HTTP status codes to include",
                "user_agent": "Custom User-Agent string",
            },
            "features": [
                "Directory enumeration",
                "File discovery",
                "Multiple tool support",
                "Custom wordlists",
                "File extension testing",
                "Interesting path detection",
                "Status code filtering",
            ],
        }

    def quick_directory_scan(self, target: str) -> ScanResult:
        """
        Perform a quick directory scan (small wordlist)

        Args:
            target: Target URL, domain, or IP

        Returns:
            ScanResult: Scan results
        """
        options = {"wordlist": "small", "extensions": False, "tool": "auto"}
        return self.scan(target, options)

    def full_directory_scan(self, target: str) -> ScanResult:
        """
        Perform a comprehensive directory scan (large wordlist + extensions)

        Args:
            target: Target URL, domain, or IP

        Returns:
            ScanResult: Scan results
        """
        options = {
            "wordlist": "big",
            "extensions": True,
            "extension_list": self.file_extensions,
            "tool": "auto",
            "threads": 20,
        }
        return self.scan(target, options)

"""
Network Vulnerability Scanner
Advanced network security assessment using Nuclei and custom analysis
"""

import json
import re
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse

from ...core.scanner_base import ScannerBase, ScanResult, ScanStatus, ScanSeverity
from ...core.executor import CommandExecutor
from ...core.validator import validate_ip, validate_domain, validate_url
from ...utils.logger import log_info, log_error, log_warning, log_success


class NetworkScanner(ScannerBase):
    """Network vulnerability scanner using Nuclei and custom analysis"""

    def __init__(self, timeout: int = 600):
        """
        Initialize Network Scanner

        Args:
            timeout: Scan timeout in seconds (default: 10 minutes)
        """
        super().__init__("network_scanner", timeout)
        self.executor = CommandExecutor()

        # Try to find nuclei binary in different locations
        self.nuclei_binary = self._find_nuclei_binary()
        self.supported_protocols = ["http", "https", "tcp", "udp"]

    def _find_nuclei_binary(self) -> str:
        """Find nuclei binary in system"""
        # Since we know it's at /usr/bin/nuclei, let's use that directly
        nuclei_path = "/usr/bin/nuclei"

        try:
            result = subprocess.run(
                [nuclei_path, "-version"], capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                log_info(f"✅ Found working nuclei at: {nuclei_path}")
                return nuclei_path
        except Exception as e:
            log_warning(f"⚠️ Could not verify nuclei at {nuclei_path}: {e}")

        # Fallback to other common locations
        possible_paths = [
            "nuclei",
            "/usr/local/bin/nuclei",
            "/opt/nuclei/nuclei",
            "/snap/bin/nuclei",
        ]

        for path in possible_paths:
            try:
                result = subprocess.run(
                    [path, "-version"], capture_output=True, text=True, timeout=5
                )
                if result.returncode == 0:
                    log_info(f"✅ Found working nuclei at: {path}")
                    return path
            except (FileNotFoundError, subprocess.TimeoutExpired):
                continue

        log_warning("⚠️ Nuclei binary not found in common locations")
        return nuclei_path  # Use the known path as fallback

    def validate_target(self, target: str) -> bool:
        """
        Validate target for network scanning

        Args:
            target: Target to validate (IP, domain, or URL)

        Returns:
            bool: True if target is valid
        """
        if not target or not isinstance(target, str):
            return False

        target = target.strip()

        # Check if it's a valid IP address
        if validate_ip(target):
            return True

        # Check if it's a valid domain
        if validate_domain(target):
            return True

        # Check if it's a valid URL
        if validate_url(target):
            return True

        # Check if it's IP:port format
        if self._validate_ip_port(target):
            return True

        return False

    def _validate_ip_port(self, target: str) -> bool:
        """Validate IP:port format"""
        try:
            if ":" in target:
                ip, port = target.split(":", 1)
                return validate_ip(ip) and port.isdigit() and 1 <= int(port) <= 65535
        except ValueError:
            pass
        return False

    def _execute_scan(self, target: str, options: Dict[str, Any]) -> ScanResult:
        """
        Execute network vulnerability scan

        Args:
            target: Target to scan
            options: Scan options

        Returns:
            ScanResult: Scan results
        """
        log_info(f"Starting network vulnerability scan on {target}")

        result = ScanResult(
            scanner_name=self.name,
            target=target,
            status=ScanStatus.RUNNING,
            start_time=datetime.now(),
        )

        try:
            # Check if Nuclei is available
            if not self._check_nuclei_available():
                error_msg = (
                    "Nuclei not found. Please install Nuclei for network scanning"
                )
                log_error(error_msg)
                result.errors.append(error_msg)
                result.status = ScanStatus.FAILED
                return result

            # Run Nuclei scan
            nuclei_findings = self._run_nuclei_scan(target, options)
            if nuclei_findings:
                result.findings.extend(nuclei_findings)

            # Run custom network analysis
            custom_findings = self._run_custom_analysis(target, options)
            if custom_findings:
                result.findings.extend(custom_findings)

            # Update metadata
            result.metadata.update(
                {
                    "nuclei_templates_used": options.get("templates", "default"),
                    "scan_type": "network_vulnerability",
                    "total_vulnerabilities": len(result.findings),
                    "severity_breakdown": self._get_severity_breakdown(result.findings),
                }
            )

            result.status = ScanStatus.COMPLETED
            log_success(f"Network scan completed with {len(result.findings)} findings")

        except Exception as e:
            error_msg = f"Scan failed: {str(e)}"
            log_error(error_msg)
            result.errors.append(error_msg)
            result.status = ScanStatus.FAILED

        finally:
            result.end_time = datetime.now()

        return result

    def _check_nuclei_available(self) -> bool:
        """Check if Nuclei is available in system"""
        try:
            # Use the detected binary path
            result = subprocess.run(
                [self.nuclei_binary, "-version"],
                capture_output=True,
                text=True,
                timeout=10,
            )

            if result.returncode == 0:
                log_info(f"✅ Nuclei found and working at {self.nuclei_binary}")
                log_info(f"📋 Version info: {result.stdout.strip()[:100]}...")
                return True
            else:
                log_warning(
                    f"❌ Nuclei version check failed with exit code: {result.returncode}"
                )
                if result.stderr:
                    log_warning(f"stderr: {result.stderr}")
                return False

        except FileNotFoundError:
            log_warning(f"❌ Nuclei binary not found at: {self.nuclei_binary}")
            return False
        except subprocess.TimeoutExpired:
            log_warning("❌ Nuclei version check timed out")
            return False
        except Exception as e:
            log_warning(f"❌ Nuclei availability check failed: {str(e)}")
            return False

    def _run_nuclei_scan(
        self, target: str, options: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Run Nuclei vulnerability scan

        Args:
            target: Target to scan
            options: Scan options

        Returns:
            List of findings
        """
        findings = []

        try:
            # Prepare Nuclei command for the user's version (v3.4.6)
            # First try with JSON, if that fails we'll try text output
            cmd = [
                self.nuclei_binary,
                "-target",
                target,  # Use -target for single target
                "-je",  # JSON export format (as shown in original command)
                "-silent",
                "-no-color",  # Disable color output for cleaner parsing
            ]

            # Add template selection
            templates = options.get("templates", "default")
            if templates == "all":
                # Don't add severity filter for all templates
                pass
            elif templates == "critical":
                cmd.extend(["-severity", "critical"])
            elif templates == "high":
                cmd.extend(["-severity", "high,critical"])
            elif templates == "medium":
                cmd.extend(["-severity", "medium,high,critical"])
            elif templates == "custom" and options.get("template_path"):
                cmd.extend(["-t", options.get("template_path")])
            else:
                # Default: medium and above
                cmd.extend(["-severity", "medium,high,critical"])

            # Add rate limiting (v3.4.6 syntax)
            rate_limit = options.get("rate_limit", 150)
            cmd.extend(["-rate-limit", str(rate_limit)])

            # Add other nuclei v3.4.6 optimizations
            cmd.extend(["-retries", "2"])  # Retry failed requests
            cmd.extend(["-timeout", "10"])  # Timeout per template

            log_info("📋 Trying JSON output format (-j flag)")

            # Execute Nuclei directly with subprocess for better control
            try:
                log_info(f"🚀 Executing: {' '.join(cmd)}")

                result = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=self.timeout
                )

                log_info(f"📤 Nuclei exit code: {result.returncode}")

                # Log stderr for debugging (nuclei often puts info in stderr)
                if result.stderr:
                    log_info(f"📋 Nuclei stderr: {result.stderr.strip()}")

                # Debug: Show actual stdout content
                if result.stdout:
                    log_info(
                        f"📄 Nuclei stdout content preview: '{result.stdout[:200]}...'"
                    )

                if result.returncode == 0:
                    if result.stdout:
                        log_info(f"📄 Nuclei output length: {len(result.stdout)} chars")

                        # Try to determine output format and parse accordingly
                        stdout_stripped = result.stdout.strip()

                        if stdout_stripped.startswith(
                            "{"
                        ) or stdout_stripped.startswith("[{"):
                            # Looks like JSON
                            findings = self._parse_nuclei_output(stdout_stripped)
                        else:
                            # This is text format - use text parser
                            log_info("📋 Output is in text format, using text parser")
                            findings = self._parse_nuclei_text_output(stdout_stripped)

                        log_info(f"🔍 Parsed {len(findings)} findings")
                    else:
                        log_info("📭 Nuclei scan completed with no stdout output")
                        # Maybe the results are in stderr?
                        if result.stderr and "matches found" in result.stderr:
                            log_info("🔍 Trying to parse results from stderr...")
                            findings = self._extract_findings_from_stderr(result.stderr)
                elif result.returncode == 2:
                    # Exit code 2 usually means "no vulnerabilities found" - this is normal
                    log_info(
                        "✅ Nuclei scan completed - no vulnerabilities found (exit code 2 is normal)"
                    )
                    if result.stdout:
                        stdout_stripped = result.stdout.strip()
                        if stdout_stripped.startswith(
                            "{"
                        ) or stdout_stripped.startswith("["):
                            findings = self._parse_nuclei_output(stdout_stripped)
                        else:
                            findings = self._parse_nuclei_text_output(stdout_stripped)
                        log_info(f"🔍 Parsed {len(findings)} findings")
                else:
                    error_msg = (
                        f"❌ Nuclei scan had issues with exit code {result.returncode}"
                    )
                    if result.stderr:
                        error_msg += f"\nSTDERR: {result.stderr}"
                    log_warning(error_msg)
                    # Still try to parse any output
                    if result.stdout:
                        stdout_stripped = result.stdout.strip()
                        if stdout_stripped.startswith(
                            "{"
                        ) or stdout_stripped.startswith("["):
                            findings = self._parse_nuclei_output(stdout_stripped)
                        else:
                            findings = self._parse_nuclei_text_output(stdout_stripped)

            except subprocess.TimeoutExpired:
                log_error(f"⏰ Nuclei scan timed out after {self.timeout} seconds")
            except Exception as e:
                log_error(f"💥 Error executing Nuclei command: {str(e)}")

        except Exception as e:
            log_error(f"💥 Error preparing Nuclei scan: {str(e)}")

        return findings

    def _parse_nuclei_text_output(self, output: str) -> List[Dict[str, Any]]:
        """
        Parse Nuclei text output (when JSON not available)

        Args:
            output: Raw Nuclei text output

        Returns:
            List of parsed findings
        """
        findings = []

        try:
            lines = output.strip().split("\n")

            for line in lines:
                line = line.strip()
                if not line:
                    continue

                # Nuclei text output format: [template-id] [optional-severity] target-info
                # Examples:
                # [CVE-2012-1823]   http://10.17.111.17/index.php?...
                # [CVE-2004-2687]   10.17.111.17:3632
                # [CVE-2011-2523]  [critical]  10.17.111.17:6200

                # Extract template ID from brackets
                template_match = re.match(r"\[([^\]]+)\]\s*(.*)", line)
                if template_match:
                    template_id = template_match.group(1)
                    rest_of_line = template_match.group(2).strip()

                    # Check if there's a severity in brackets
                    severity = "info"  # default
                    target_info = rest_of_line

                    # Look for severity in brackets like [critical], [high], etc.
                    severity_match = re.search(r"\[([^\]]+)\]", rest_of_line)
                    if severity_match:
                        potential_severity = severity_match.group(1).lower()
                        if potential_severity in [
                            "critical",
                            "high",
                            "medium",
                            "low",
                            "info",
                        ]:
                            severity = potential_severity
                            # Remove severity from target info
                            target_info = re.sub(
                                r"\s*\[[^\]]+\]\s*", " ", rest_of_line
                            ).strip()
                    else:
                        # Guess severity from template ID
                        severity = self._guess_severity_from_template_id(template_id)

                    # Clean up target info
                    if not target_info:
                        target_info = "Target not specified"

                    # Create finding
                    finding = {
                        "type": "vulnerability",
                        "id": template_id,
                        "title": f"Security Vulnerability: {template_id}",
                        "description": f"Vulnerability {template_id} detected at {target_info}",
                        "severity": self._map_nuclei_severity(severity),
                        "matched_at": target_info,
                        "template_id": template_id,
                        "classification": {
                            "cve": (
                                template_id if template_id.startswith("CVE") else None
                            )
                        },
                        "references": self._get_references_for_template(template_id),
                        "recommendation": self._generate_recommendation(
                            {"template-id": template_id}
                        ),
                        "timestamp": datetime.now().isoformat(),
                    }

                    findings.append(finding)
                    log_info(
                        f"🎯 Parsed vulnerability: {template_id} ({severity}) at {target_info[:50]}..."
                    )
                else:
                    # Try alternative format parsing
                    log_warning(f"Could not parse line format: {line[:100]}...")

        except Exception as e:
            log_warning(f"Failed to parse nuclei text output: {e}")

        return findings

    def _guess_severity_from_template_id(self, template_id: str) -> str:
        """Guess severity from template ID"""
        template_lower = template_id.lower()

        # CVE severity guessing based on common patterns
        if any(word in template_lower for word in ["rce", "injection", "sqli", "exec"]):
            return "critical"
        elif any(word in template_lower for word in ["xss", "csrf", "lfi", "upload"]):
            return "high"
        elif any(word in template_lower for word in ["disclosure", "enum", "bypass"]):
            return "medium"
        elif any(word in template_lower for word in ["version", "detect", "banner"]):
            return "low"
        else:
            return "medium"  # default for unknown

    def _get_references_for_template(self, template_id: str) -> List[str]:
        """Get references for a template"""
        references = []

        if template_id.startswith("CVE-"):
            references.append(
                f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={template_id}"
            )
            references.append(f"https://nvd.nist.gov/vuln/detail/{template_id}")

        return references

    def _extract_severity_from_text(self, text: str) -> str:
        """Extract severity from nuclei text output"""
        text_lower = text.lower()

        if any(word in text_lower for word in ["critical", "crit"]):
            return ScanSeverity.CRITICAL.value
        elif any(word in text_lower for word in ["high"]):
            return ScanSeverity.HIGH.value
        elif any(word in text_lower for word in ["medium", "med"]):
            return ScanSeverity.MEDIUM.value
        elif any(word in text_lower for word in ["low"]):
            return ScanSeverity.LOW.value
        else:
            return ScanSeverity.INFO.value

    def _extract_url_from_text(self, text: str) -> str:
        """Extract URL from nuclei text output"""
        # Simple URL extraction
        url_pattern = r"https?://[^\s\]]+|[^\s\[]+:[0-9]+(?:/[^\s\]]*)?"
        match = re.search(url_pattern, text)

    def _extract_findings_from_stderr(self, stderr: str) -> List[Dict[str, Any]]:
        """
        Extract findings from stderr when stdout doesn't have results

        Args:
            stderr: Nuclei stderr output

        Returns:
            List of findings extracted from stderr
        """
        findings = []

        try:
            lines = stderr.strip().split("\n")

            for line in lines:
                line = line.strip()

                # Look for vulnerability patterns in stderr
                # Example: [CVE-2011-2523] [tcp] [critical] 10.17.111.17:6200
                if re.match(r"\[.*\]\s*\[.*\]\s*\[.*\]", line):
                    try:
                        # Parse the bracket format
                        parts = re.findall(r"\[(.*?)\]", line)
                        if len(parts) >= 3:
                            vuln_id = parts[0]
                            protocol = parts[1] if len(parts) > 1 else "unknown"
                            severity = parts[2] if len(parts) > 2 else "info"

                            # Extract target info (everything after the brackets)
                            target_part = re.sub(r"\[.*?\]\s*", "", line).strip()

                            finding = {
                                "type": "vulnerability",
                                "id": vuln_id,
                                "title": f"Security Vulnerability: {vuln_id}",
                                "description": f"Vulnerability {vuln_id} detected via {protocol} protocol",
                                "severity": self._map_nuclei_severity(severity),
                                "matched_at": target_part,
                                "protocol": protocol,
                                "classification": {
                                    "cve": (
                                        vuln_id if vuln_id.startswith("CVE") else None
                                    )
                                },
                                "references": (
                                    [
                                        f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={vuln_id}"
                                    ]
                                    if vuln_id.startswith("CVE")
                                    else []
                                ),
                                "recommendation": self._generate_recommendation(
                                    {"template-id": vuln_id}
                                ),
                                "timestamp": datetime.now().isoformat(),
                            }

                            findings.append(finding)
                            log_info(
                                f"🎯 Extracted finding: {vuln_id} ({severity}) from stderr"
                            )

                    except Exception as e:
                        log_warning(f"Failed to parse stderr line '{line}': {e}")
                        continue

        except Exception as e:
            log_warning(f"Failed to extract findings from stderr: {e}")

        return findings

    def _parse_nuclei_output(self, output: str) -> List[Dict[str, Any]]:
        """
        Parse Nuclei JSON output

        Args:
            output: Raw Nuclei output

        Returns:
            List of parsed findings
        """
        findings = []

        for line in output.strip().split("\n"):
            if not line.strip():
                continue

            try:
                vuln_data = json.loads(line)

                # Extract vulnerability information
                finding = {
                    "type": "vulnerability",
                    "id": vuln_data.get("template-id", "unknown"),
                    "title": vuln_data.get("info", {}).get(
                        "name", "Unknown Vulnerability"
                    ),
                    "description": vuln_data.get("info", {}).get(
                        "description", "No description available"
                    ),
                    "severity": self._map_nuclei_severity(
                        vuln_data.get("info", {}).get("severity", "info")
                    ),
                    "matched_at": vuln_data.get("matched-at", ""),
                    "matcher_name": vuln_data.get("matcher-name", ""),
                    "extracted_results": vuln_data.get("extracted-results", []),
                    "classification": vuln_data.get("info", {}).get(
                        "classification", {}
                    ),
                    "references": vuln_data.get("info", {}).get("reference", []),
                    "tags": vuln_data.get("info", {}).get("tags", []),
                    "recommendation": self._generate_recommendation(vuln_data),
                    "timestamp": datetime.now().isoformat(),
                }

                findings.append(finding)

            except json.JSONDecodeError as e:
                log_warning(f"Failed to parse Nuclei output line: {e}")
                continue

        return findings

    def _map_nuclei_severity(self, severity: str) -> str:
        """Map Nuclei severity to our standard severity levels"""
        severity_map = {
            "info": ScanSeverity.INFO.value,
            "low": ScanSeverity.LOW.value,
            "medium": ScanSeverity.MEDIUM.value,
            "high": ScanSeverity.HIGH.value,
            "critical": ScanSeverity.CRITICAL.value,
        }

        return severity_map.get(severity.lower(), ScanSeverity.INFO.value)

    def _generate_recommendation(self, vuln_data: Dict[str, Any]) -> str:
        """Generate security recommendation based on vulnerability data"""
        vuln_id = vuln_data.get("template-id", "")
        vuln_info = vuln_data.get("info", {})

        # Basic recommendations based on vulnerability type
        if "sql" in vuln_id.lower() or "sqli" in vuln_id.lower():
            return "Implement parameterized queries and input validation to prevent SQL injection attacks."
        elif "xss" in vuln_id.lower():
            return "Implement proper output encoding and Content Security Policy (CSP) to prevent XSS attacks."
        elif "lfi" in vuln_id.lower() or "file-inclusion" in vuln_id.lower():
            return "Validate and sanitize file paths, implement access controls, and avoid dynamic file inclusion."
        elif "rce" in vuln_id.lower() or "command" in vuln_id.lower():
            return "Implement input validation, avoid system command execution, and use secure alternatives."
        elif "auth" in vuln_id.lower() or "login" in vuln_id.lower():
            return "Implement strong authentication mechanisms, multi-factor authentication, and secure session management."
        elif "disclosure" in vuln_id.lower() or "exposure" in vuln_id.lower():
            return "Remove sensitive information from public access and implement proper access controls."
        else:
            return "Review the vulnerability details and implement appropriate security controls as recommended by security best practices."

    def _run_custom_analysis(
        self, target: str, options: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Run custom network analysis

        Args:
            target: Target to analyze
            options: Analysis options

        Returns:
            List of findings
        """
        findings = []

        try:
            # Basic network service analysis
            if options.get("service_analysis", True):
                service_findings = self._analyze_network_services(target)
                findings.extend(service_findings)

            # Protocol security analysis
            if options.get("protocol_analysis", True):
                protocol_findings = self._analyze_protocols(target)
                findings.extend(protocol_findings)

        except Exception as e:
            log_error(f"Custom analysis failed: {str(e)}")

        return findings

    def _analyze_network_services(self, target: str) -> List[Dict[str, Any]]:
        """Analyze network services for common security issues"""
        findings = []

        # This is a placeholder for future service analysis
        # Will be expanded in future iterations

        return findings

    def _analyze_protocols(self, target: str) -> List[Dict[str, Any]]:
        """Analyze network protocols for security issues"""
        findings = []

        # This is a placeholder for future protocol analysis
        # Will be expanded in future iterations

        return findings

    def _get_severity_breakdown(self, findings: List[Dict[str, Any]]) -> Dict[str, int]:
        """Get breakdown of findings by severity"""
        breakdown = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}

        for finding in findings:
            severity = finding.get("severity", "info")
            if severity in breakdown:
                breakdown[severity] += 1

        return breakdown

    def get_capabilities(self) -> Dict[str, Any]:
        """
        Get scanner capabilities

        Returns:
            Dict containing scanner capabilities
        """
        return {
            "name": "Network Vulnerability Scanner",
            "description": "Advanced network vulnerability assessment using Nuclei and custom analysis",
            "version": "1.0.0",
            "author": "Auto-Pentest Framework",
            "supported_targets": ["ip", "domain", "url", "ip:port"],
            "supported_protocols": self.supported_protocols,
            "features": [
                "nuclei_integration",
                "vulnerability_detection",
                "custom_network_analysis",
                "severity_classification",
                "comprehensive_reporting",
            ],
            "requirements": ["nuclei"],
            "scan_types": ["default", "critical", "high", "all", "custom"],
        }

"""
Network Vulnerability Scanner
Advanced network security assessment using Nuclei and custom analysis
"""

import json
import re
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse

from ...core.scanner_base import ScannerBase, ScanResult, ScanStatus, ScanSeverity
from ...core.executor import CommandExecutor
from ...core.validator import validate_ip, validate_domain, validate_url
from ...utils.logger import log_info, log_error, log_warning


class NetworkScanner(ScannerBase):
    """Network vulnerability scanner using Nuclei and custom analysis"""

    def __init__(self, timeout: int = 600):
        """
        Initialize Network Scanner

        Args:
            timeout: Scan timeout in seconds (default: 10 minutes)
        """
        super().__init__("network_scanner", timeout)
        self.executor = CommandExecutor()
        self.logger = log_info("scanner.network")

        # Scanner configuration
        self.nuclei_binary = "nuclei"
        self.supported_protocols = ["http", "https", "tcp", "udp"]

    def validate_target(self, target: str) -> bool:
        """
        Validate target for network scanning

        Args:
            target: Target to validate (IP, domain, or URL)

        Returns:
            bool: True if target is valid
        """
        if not target or not isinstance(target, str):
            return False

        target = target.strip()

        # Check if it's a valid IP address
        if validate_ip(target):
            return True

        # Check if it's a valid domain
        if validate_domain(target):
            return True

        # Check if it's a valid URL
        if validate_url(target):
            return True

        # Check if it's IP:port format
        if self._validate_ip_port(target):
            return True

        return False

    def _validate_ip_port(self, target: str) -> bool:
        """Validate IP:port format"""
        try:
            if ":" in target:
                ip, port = target.split(":", 1)
                return validate_ip(ip) and port.isdigit() and 1 <= int(port) <= 65535
        except ValueError:
            pass
        return False

    def _execute_scan(self, target: str, options: Dict[str, Any]) -> ScanResult:
        """
        Execute network vulnerability scan

        Args:
            target: Target to scan
            options: Scan options

        Returns:
            ScanResult: Scan results
        """
        log_info(f"Starting network vulnerability scan on {target}")

        result = ScanResult(
            scanner_name=self.name,
            target=target,
            status=ScanStatus.RUNNING,
            start_time=datetime.now(),
        )

        try:
            # Check if Nuclei is available
            if not self._check_nuclei_available():
                result.errors.append(
                    "Nuclei not found. Please install Nuclei for network scanning"
                )
                result.status = ScanStatus.FAILED
                return result

            # Run Nuclei scan
            nuclei_findings = self._run_nuclei_scan(target, options)
            result.findings.extend(nuclei_findings)

            # Run custom network analysis
            custom_findings = self._run_custom_analysis(target, options)
            result.findings.extend(custom_findings)

            # Update metadata
            result.metadata.update(
                {
                    "nuclei_templates_used": options.get("templates", "default"),
                    "scan_type": "network_vulnerability",
                    "total_vulnerabilities": len(result.findings),
                    "severity_breakdown": self._get_severity_breakdown(result.findings),
                }
            )

            result.status = ScanStatus.COMPLETED
            log_info(f"Network scan completed with {len(result.findings)} findings")

        except Exception as e:
            log_error(f"Network scan failed: {str(e)}")
            result.errors.append(f"Scan failed: {str(e)}")
            result.status = ScanStatus.FAILED

        finally:
            result.end_time = datetime.now()

        return result

    def _check_nuclei_available(self) -> bool:
        """Check if Nuclei is available in system"""
        try:
            result = self.executor.execute([self.nuclei_binary, "-version"])
            return result.return_code == 0
        except Exception:
            return False

    def _run_nuclei_scan(
        self, target: str, options: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Run Nuclei vulnerability scan

        Args:
            target: Target to scan
            options: Scan options

        Returns:
            List of findings
        """
        findings = []

        try:
            # Prepare Nuclei command
            cmd = [self.nuclei_binary, "-target", target, "-json", "-silent"]

            # Add template selection
            templates = options.get("templates", "default")
            if templates == "all":
                cmd.extend(["-as"])  # All severity
            elif templates == "critical":
                cmd.extend(["-severity", "critical"])
            elif templates == "high":
                cmd.extend(["-severity", "high,critical"])
            elif templates == "custom" and options.get("template_path"):
                cmd.extend(["-t", options.get("template_path")])
            else:
                # Default: medium and above
                cmd.extend(["-severity", "medium,high,critical"])

            # Add rate limiting
            rate_limit = options.get("rate_limit", 150)
            cmd.extend(["-rate-limit", str(rate_limit)])

            # Execute Nuclei
            result = self.executor.execute(cmd, timeout=self.timeout)

            if result.return_code == 0:
                findings = self._parse_nuclei_output(result.stdout)
            else:
                log_warning(f"Nuclei scan had issues: {result.stderr}")

        except Exception as e:
            log_error(f"Nuclei scan failed: {str(e)}")

        return findings

    def _parse_nuclei_output(self, output: str) -> List[Dict[str, Any]]:
        """
        Parse Nuclei JSON output

        Args:
            output: Raw Nuclei output

        Returns:
            List of parsed findings
        """
        findings = []

        for line in output.strip().split("\n"):
            if not line.strip():
                continue

            try:
                vuln_data = json.loads(line)

                # Extract vulnerability information
                finding = {
                    "type": "vulnerability",
                    "id": vuln_data.get("template-id", "unknown"),
                    "title": vuln_data.get("info", {}).get(
                        "name", "Unknown Vulnerability"
                    ),
                    "description": vuln_data.get("info", {}).get(
                        "description", "No description available"
                    ),
                    "severity": self._map_nuclei_severity(
                        vuln_data.get("info", {}).get("severity", "info")
                    ),
                    "matched_at": vuln_data.get("matched-at", ""),
                    "matcher_name": vuln_data.get("matcher-name", ""),
                    "extracted_results": vuln_data.get("extracted-results", []),
                    "classification": vuln_data.get("info", {}).get(
                        "classification", {}
                    ),
                    "references": vuln_data.get("info", {}).get("reference", []),
                    "tags": vuln_data.get("info", {}).get("tags", []),
                    "recommendation": self._generate_recommendation(vuln_data),
                    "timestamp": datetime.now().isoformat(),
                }

                findings.append(finding)

            except json.JSONDecodeError as e:
                log_warning(f"Failed to parse Nuclei output line: {e}")
                continue

        return findings

    def _map_nuclei_severity(self, severity: str) -> str:
        """Map Nuclei severity to our standard severity levels"""
        severity_map = {
            "info": ScanSeverity.INFO.value,
            "low": ScanSeverity.LOW.value,
            "medium": ScanSeverity.MEDIUM.value,
            "high": ScanSeverity.HIGH.value,
            "critical": ScanSeverity.CRITICAL.value,
        }

        return severity_map.get(severity.lower(), ScanSeverity.INFO.value)

    def _generate_recommendation(self, vuln_data: Dict[str, Any]) -> str:
        """Generate security recommendation based on vulnerability data"""
        vuln_id = vuln_data.get("template-id", "")
        vuln_info = vuln_data.get("info", {})

        # Basic recommendations based on vulnerability type
        if "sql" in vuln_id.lower() or "sqli" in vuln_id.lower():
            return "Implement parameterized queries and input validation to prevent SQL injection attacks."
        elif "xss" in vuln_id.lower():
            return "Implement proper output encoding and Content Security Policy (CSP) to prevent XSS attacks."
        elif "lfi" in vuln_id.lower() or "file-inclusion" in vuln_id.lower():
            return "Validate and sanitize file paths, implement access controls, and avoid dynamic file inclusion."
        elif "rce" in vuln_id.lower() or "command" in vuln_id.lower():
            return "Implement input validation, avoid system command execution, and use secure alternatives."
        elif "auth" in vuln_id.lower() or "login" in vuln_id.lower():
            return "Implement strong authentication mechanisms, multi-factor authentication, and secure session management."
        elif "disclosure" in vuln_id.lower() or "exposure" in vuln_id.lower():
            return "Remove sensitive information from public access and implement proper access controls."
        else:
            return "Review the vulnerability details and implement appropriate security controls as recommended by security best practices."

    def _run_custom_analysis(
        self, target: str, options: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Run custom network analysis

        Args:
            target: Target to analyze
            options: Analysis options

        Returns:
            List of findings
        """
        findings = []

        try:
            # Basic network service analysis
            if options.get("service_analysis", True):
                service_findings = self._analyze_network_services(target)
                findings.extend(service_findings)

            # Protocol security analysis
            if options.get("protocol_analysis", True):
                protocol_findings = self._analyze_protocols(target)
                findings.extend(protocol_findings)

        except Exception as e:
            log_error(f"Custom analysis failed: {str(e)}")

        return findings

    def _analyze_network_services(self, target: str) -> List[Dict[str, Any]]:
        """Analyze network services for common security issues"""
        findings = []

        # This is a placeholder for future service analysis
        # Will be expanded in future iterations

        return findings

    def _analyze_protocols(self, target: str) -> List[Dict[str, Any]]:
        """Analyze network protocols for security issues"""
        findings = []

        # This is a placeholder for future protocol analysis
        # Will be expanded in future iterations

        return findings

    def _get_severity_breakdown(self, findings: List[Dict[str, Any]]) -> Dict[str, int]:
        """Get breakdown of findings by severity"""
        breakdown = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}

        for finding in findings:
            severity = finding.get("severity", "info")
            if severity in breakdown:
                breakdown[severity] += 1

        return breakdown

    def get_capabilities(self) -> Dict[str, Any]:
        """
        Get scanner capabilities

        Returns:
            Dict containing scanner capabilities
        """
        return {
            "name": "Network Vulnerability Scanner",
            "description": "Advanced network vulnerability assessment using Nuclei and custom analysis",
            "version": "1.0.0",
            "author": "Auto-Pentest Framework",
            "supported_targets": ["ip", "domain", "url", "ip:port"],
            "supported_protocols": self.supported_protocols,
            "features": [
                "nuclei_integration",
                "vulnerability_detection",
                "custom_network_analysis",
                "severity_classification",
                "comprehensive_reporting",
            ],
            "requirements": ["nuclei"],
            "scan_types": ["default", "critical", "high", "all", "custom"],
        }

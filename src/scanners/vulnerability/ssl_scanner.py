"""
SSL/TLS Scanner Module - Certificate and Configuration Analysis
"""

import ssl
import socket
import json
import re
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path
from urllib.parse import urlparse
import subprocess

from src.core import ScannerBase, ScanResult, ScanStatus, ScanSeverity
from src.core import CommandExecutor, validate_url, validate_domain, validate_ip
from src.utils.logger import log_info, log_error, log_warning


class SSLScanner(ScannerBase):
    """
    SSL/TLS scanner for certificate and configuration analysis
    """

    def __init__(self, timeout: int = 120):
        """
        Initialize SSL scanner

        Args:
            timeout: Scan timeout in seconds
        """
        super().__init__("ssl_scanner", timeout=timeout)
        self.executor = CommandExecutor(timeout=self.timeout)

        # SSL/TLS protocols to test
        self.ssl_protocols = {
            "SSLv2": ssl.PROTOCOL_SSLv23,  # Will be restricted
            "SSLv3": ssl.PROTOCOL_SSLv23,  # Will be restricted
            "TLSv1.0": ssl.PROTOCOL_TLSv1 if hasattr(ssl, "PROTOCOL_TLSv1") else None,
            "TLSv1.1": (
                ssl.PROTOCOL_TLSv1_1 if hasattr(ssl, "PROTOCOL_TLSv1_1") else None
            ),
            "TLSv1.2": (
                ssl.PROTOCOL_TLSv1_2 if hasattr(ssl, "PROTOCOL_TLSv1_2") else None
            ),
            "TLSv1.3": ssl.PROTOCOL_TLS if hasattr(ssl, "PROTOCOL_TLS") else None,
        }

        # Weak cipher suites patterns
        self.weak_ciphers = [
            "NULL",
            "aNULL",
            "eNULL",
            "EXPORT",
            "DES",
            "RC4",
            "MD5",
            "PSK",
            "SRP",
            "KRB5",
            "ADH",
            "AECDH",
        ]

        # Strong cipher preferences
        self.strong_ciphers = ["AES256", "AES128", "CHACHA20", "ECDHE", "DHE"]

    def validate_target(self, target: str) -> bool:
        """
        Validate if target is appropriate for SSL scanning

        Args:
            target: Target URL, domain, or IP

        Returns:
            bool: True if valid target, False otherwise
        """
        # Accept URLs, domains, and IPs
        if target.startswith(("https://", "http://")):
            return validate_url(target)
        return validate_domain(target) or validate_ip(target)

    def _execute_scan(self, target: str, options: Dict[str, Any]) -> ScanResult:
        """
        Execute SSL/TLS scan

        Args:
            target: Target to scan
            options: Scan options

        Returns:
            ScanResult: Parsed scan results
        """
        result = ScanResult(
            scanner_name=self.name,
            target=target,
            status=ScanStatus.RUNNING,
            start_time=datetime.now(),
        )

        try:
            # Parse target to get host and port
            host, port = self._parse_target(target, options)
            result.target = f"{host}:{port}"

            self.logger.info(f"Starting SSL scan on: {host}:{port}")

            # Phase 1: Certificate Analysis
            self._analyze_certificate(host, port, result)

            # Phase 2: Protocol Support Testing
            self._test_protocol_support(host, port, result)

            # Phase 3: Cipher Suite Analysis
            self._analyze_cipher_suites(host, port, result)

            # Phase 4: SSL/TLS Configuration Testing
            self._test_ssl_configuration(host, port, result)

            # Phase 5: External Tool Scanning (if available)
            if options.get("use_sslscan", True):
                self._run_sslscan(host, port, result)

            # Phase 6: Vulnerability Testing
            self._test_ssl_vulnerabilities(host, port, result)

            result.status = ScanStatus.COMPLETED
            self.logger.info(
                f"SSL scan completed. Found {len(result.findings)} findings"
            )

        except Exception as e:
            result.status = ScanStatus.FAILED
            result.errors.append(f"SSL scan failed: {str(e)}")
            self.logger.error(f"SSL scan error: {e}")

        return result

    def _parse_target(self, target: str, options: Dict[str, Any]) -> Tuple[str, int]:
        """
        Parse target to extract host and port

        Args:
            target: Target string
            options: Scan options

        Returns:
            Tuple[str, int]: (host, port)
        """
        # Default port
        default_port = 443

        if target.startswith(("http://", "https://")):
            parsed = urlparse(target)
            host = parsed.hostname
            port = parsed.port or (443 if parsed.scheme == "https" else 80)
        else:
            # Handle host:port format
            if ":" in target:
                host, port_str = target.rsplit(":", 1)
                try:
                    port = int(port_str)
                except ValueError:
                    host = target
                    port = default_port
            else:
                host = target
                port = options.get("port", default_port)

        return host, port

    def _analyze_certificate(self, host: str, port: int, result: ScanResult) -> None:
        """
        Analyze SSL certificate

        Args:
            host: Target hostname
            port: Target port
            result: ScanResult to populate
        """
        try:
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            # Connect and get certificate
            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert_der = ssock.getpeercert_chain()[0]
                    cert_info = ssock.getpeercert()

                    # Analyze certificate details
                    self._process_certificate_info(cert_info, result)

                    # Store raw certificate info
                    result.metadata["certificate"] = cert_info

        except socket.timeout:
            result.errors.append(f"Connection timeout to {host}:{port}")
        except ssl.SSLError as e:
            result.errors.append(f"SSL error: {str(e)}")
        except Exception as e:
            result.errors.append(f"Certificate analysis failed: {str(e)}")
            self.logger.error(f"Certificate analysis error: {e}")

    def _process_certificate_info(self, cert_info: Dict, result: ScanResult) -> None:
        """
        Process and analyze certificate information

        Args:
            cert_info: Certificate information dictionary
            result: ScanResult to populate
        """
        try:
            # Basic certificate info
            subject = dict(x[0] for x in cert_info.get("subject", []))
            issuer = dict(x[0] for x in cert_info.get("issuer", []))

            common_name = subject.get("commonName", "Unknown")
            organization = subject.get("organizationName", "Unknown")
            issuer_name = issuer.get("organizationName", "Unknown")

            # Certificate validity dates
            not_before = cert_info.get("notBefore")
            not_after = cert_info.get("notAfter")

            if not_before and not_after:
                # Parse dates
                not_before_dt = datetime.strptime(not_before, "%b %d %H:%M:%S %Y %Z")
                not_after_dt = datetime.strptime(not_after, "%b %d %H:%M:%S %Y %Z")

                # Check expiration
                now = datetime.now()
                days_until_expiry = (not_after_dt - now).days

                if days_until_expiry < 0:
                    result.add_finding(
                        title="Expired SSL Certificate",
                        description=f"Certificate expired on {not_after}",
                        severity=ScanSeverity.CRITICAL,
                        category="certificate_validity",
                        expiry_date=not_after,
                        days_expired=abs(days_until_expiry),
                    )
                elif days_until_expiry < 30:
                    result.add_finding(
                        title="SSL Certificate Expiring Soon",
                        description=f"Certificate expires in {days_until_expiry} days ({not_after})",
                        severity=ScanSeverity.HIGH,
                        category="certificate_validity",
                        expiry_date=not_after,
                        days_until_expiry=days_until_expiry,
                    )
                else:
                    result.add_finding(
                        title="Valid SSL Certificate",
                        description=f"Certificate valid until {not_after} ({days_until_expiry} days)",
                        severity=ScanSeverity.INFO,
                        category="certificate_validity",
                        expiry_date=not_after,
                        days_until_expiry=days_until_expiry,
                    )

            # Certificate details
            result.add_finding(
                title=f"Certificate Information",
                description=f"CN: {common_name}, Issuer: {issuer_name}, Org: {organization}",
                severity=ScanSeverity.INFO,
                category="certificate_info",
                common_name=common_name,
                issuer=issuer_name,
                organization=organization,
                details=cert_info,
            )

            # Subject Alternative Names
            san_list = []
            for ext in cert_info.get("subjectAltName", []):
                if ext[0] == "DNS":
                    san_list.append(ext[1])

            if san_list:
                result.add_finding(
                    title="Certificate SANs",
                    description=f"Subject Alternative Names: {', '.join(san_list)}",
                    severity=ScanSeverity.INFO,
                    category="certificate_sans",
                    san_list=san_list,
                )

            # Check for self-signed certificate
            if subject == issuer:
                result.add_finding(
                    title="Self-Signed Certificate",
                    description="Certificate is self-signed",
                    severity=ScanSeverity.MEDIUM,
                    category="certificate_trust",
                    self_signed=True,
                )

        except Exception as e:
            result.errors.append(f"Certificate processing failed: {str(e)}")
            self.logger.error(f"Certificate processing error: {e}")

    def _test_protocol_support(self, host: str, port: int, result: ScanResult) -> None:
        """
        Test SSL/TLS protocol support

        Args:
            host: Target hostname
            port: Target port
            result: ScanResult to populate
        """
        supported_protocols = []

        for protocol_name, protocol_const in self.ssl_protocols.items():
            if protocol_const is None:
                continue

            try:
                # Create context for specific protocol
                if protocol_name in ["SSLv2", "SSLv3"]:
                    # These are deprecated, test with restricted context
                    context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
                    context.options |= (
                        ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 | ssl.OP_NO_TLSv1_2
                    )
                    if hasattr(ssl, "OP_NO_TLSv1_3"):
                        context.options |= ssl.OP_NO_TLSv1_3
                    if protocol_name == "SSLv3":
                        context.options |= ssl.OP_NO_SSLv2
                else:
                    context = ssl.SSLContext(protocol_const)

                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE

                # Test connection
                with socket.create_connection((host, port), timeout=5) as sock:
                    with context.wrap_socket(sock, server_hostname=host) as ssock:
                        supported_protocols.append(protocol_name)

                        # Determine severity based on protocol
                        severity = self._determine_protocol_severity(protocol_name)

                        result.add_finding(
                            title=f"SSL/TLS Protocol: {protocol_name}",
                            description=f"Server supports {protocol_name}",
                            severity=severity,
                            category="ssl_protocol",
                            protocol=protocol_name,
                            supported=True,
                        )

            except (ssl.SSLError, socket.error, OSError):
                # Protocol not supported (expected for old protocols)
                pass
            except Exception as e:
                self.logger.debug(f"Protocol test error for {protocol_name}: {e}")

        result.metadata["supported_protocols"] = supported_protocols

        # Check for weak protocols
        weak_protocols = ["SSLv2", "SSLv3", "TLSv1.0"]
        supported_weak = [p for p in supported_protocols if p in weak_protocols]

        if supported_weak:
            result.add_finding(
                title="Weak SSL/TLS Protocols Supported",
                description=f"Server supports deprecated protocols: {', '.join(supported_weak)}",
                severity=ScanSeverity.HIGH,
                category="weak_protocols",
                weak_protocols=supported_weak,
                recommendation="Disable SSLv2, SSLv3, and TLSv1.0",
            )

    def _determine_protocol_severity(self, protocol: str) -> ScanSeverity:
        """Determine severity for SSL/TLS protocol"""
        if protocol in ["SSLv2", "SSLv3"]:
            return ScanSeverity.CRITICAL
        elif protocol in ["TLSv1.0"]:
            return ScanSeverity.HIGH
        elif protocol in ["TLSv1.1"]:
            return ScanSeverity.MEDIUM
        else:  # TLSv1.2, TLSv1.3
            return ScanSeverity.INFO

    def _analyze_cipher_suites(self, host: str, port: int, result: ScanResult) -> None:
        """
        Analyze supported cipher suites

        Args:
            host: Target hostname
            port: Target port
            result: ScanResult to populate
        """
        try:
            # Get cipher info from connection
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cipher_info = ssock.cipher()

                    if cipher_info:
                        cipher_name = cipher_info[0]
                        cipher_version = cipher_info[1]
                        cipher_bits = cipher_info[2]

                        # Analyze cipher strength
                        severity = self._determine_cipher_severity(
                            cipher_name, cipher_bits
                        )

                        result.add_finding(
                            title=f"Cipher Suite: {cipher_name}",
                            description=f"Using {cipher_name} ({cipher_version}, {cipher_bits} bits)",
                            severity=severity,
                            category="cipher_suite",
                            cipher_name=cipher_name,
                            cipher_version=cipher_version,
                            cipher_bits=cipher_bits,
                        )

                        # Check for weak ciphers
                        if any(weak in cipher_name for weak in self.weak_ciphers):
                            result.add_finding(
                                title="Weak Cipher Suite Detected",
                                description=f"Weak cipher in use: {cipher_name}",
                                severity=ScanSeverity.HIGH,
                                category="weak_cipher",
                                cipher_name=cipher_name,
                                recommendation="Use stronger cipher suites",
                            )

        except Exception as e:
            result.errors.append(f"Cipher analysis failed: {str(e)}")
            self.logger.error(f"Cipher analysis error: {e}")

    def _determine_cipher_severity(self, cipher_name: str, bits: int) -> ScanSeverity:
        """Determine severity for cipher suite"""
        if any(weak in cipher_name for weak in self.weak_ciphers):
            return ScanSeverity.HIGH
        elif bits < 128:
            return ScanSeverity.MEDIUM
        elif any(strong in cipher_name for strong in self.strong_ciphers):
            return ScanSeverity.INFO
        else:
            return ScanSeverity.LOW

    def _test_ssl_configuration(self, host: str, port: int, result: ScanResult) -> None:
        """
        Test SSL/TLS configuration

        Args:
            host: Target hostname
            port: Target port
            result: ScanResult to populate
        """
        try:
            # Test for Perfect Forward Secrecy
            self._test_perfect_forward_secrecy(host, port, result)

            # Test for HSTS header (if it's a web server)
            if port in [80, 443, 8080, 8443]:
                self._test_hsts_header(host, port, result)

        except Exception as e:
            result.errors.append(f"Configuration testing failed: {str(e)}")
            self.logger.error(f"Configuration testing error: {e}")

    def _test_perfect_forward_secrecy(
        self, host: str, port: int, result: ScanResult
    ) -> None:
        """Test for Perfect Forward Secrecy support"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            # Set ciphers that support PFS
            context.set_ciphers(
                "ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS"
            )

            with socket.create_connection((host, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cipher_info = ssock.cipher()
                    if cipher_info and (
                        "ECDHE" in cipher_info[0] or "DHE" in cipher_info[0]
                    ):
                        result.add_finding(
                            title="Perfect Forward Secrecy Supported",
                            description="Server supports Perfect Forward Secrecy",
                            severity=ScanSeverity.INFO,
                            category="ssl_configuration",
                            pfs_supported=True,
                        )

        except ssl.SSLError:
            result.add_finding(
                title="Perfect Forward Secrecy Not Supported",
                description="Server does not support Perfect Forward Secrecy",
                severity=ScanSeverity.MEDIUM,
                category="ssl_configuration",
                pfs_supported=False,
                recommendation="Enable ECDHE or DHE cipher suites",
            )
        except Exception as e:
            self.logger.debug(f"PFS test error: {e}")

    def _test_hsts_header(self, host: str, port: int, result: ScanResult) -> None:
        """Test for HSTS header"""
        try:
            import requests

            # Test HTTPS connection for HSTS
            if port == 443:
                url = f"https://{host}"
            elif port == 80:
                url = f"http://{host}"
            else:
                url = f"https://{host}:{port}"

            response = requests.head(url, timeout=10, verify=False)
            hsts_header = response.headers.get("Strict-Transport-Security")

            if hsts_header:
                result.add_finding(
                    title="HSTS Header Present",
                    description=f"HSTS header configured: {hsts_header}",
                    severity=ScanSeverity.INFO,
                    category="ssl_configuration",
                    hsts_header=hsts_header,
                )
            else:
                result.add_finding(
                    title="Missing HSTS Header",
                    description="Strict-Transport-Security header not found",
                    severity=ScanSeverity.MEDIUM,
                    category="ssl_configuration",
                    hsts_missing=True,
                    recommendation="Implement HSTS header",
                )

        except Exception as e:
            self.logger.debug(f"HSTS test error: {e}")

    def _run_sslscan(self, host: str, port: int, result: ScanResult) -> None:
        """
        Run sslscan tool if available

        Args:
            host: Target hostname
            port: Target port
            result: ScanResult to populate
        """
        if not self.executor.check_tool_exists("sslscan"):
            self.logger.debug("sslscan not found, skipping external scan")
            return

        try:
            # Build sslscan command
            sslscan_cmd = [
                "sslscan",
                "--xml=-",  # XML output to stdout
                f"{host}:{port}",
            ]

            self.logger.info(f"Running sslscan: {' '.join(sslscan_cmd)}")
            result.metadata["sslscan_command"] = " ".join(sslscan_cmd)

            # Execute sslscan
            sslscan_result = self.executor.execute(sslscan_cmd, timeout=60)
            result.metadata["sslscan_execution_time"] = sslscan_result.execution_time
            result.metadata["sslscan_return_code"] = sslscan_result.return_code

            if sslscan_result.success:
                self._parse_sslscan_output(sslscan_result.stdout, result)

                result.add_finding(
                    title="SSLScan Analysis Complete",
                    description="External SSL analysis completed with sslscan",
                    severity=ScanSeverity.INFO,
                    category="external_scan",
                    tool="sslscan",
                )
            else:
                result.errors.append(f"sslscan failed: {sslscan_result.stderr}")

        except Exception as e:
            result.errors.append(f"sslscan error: {str(e)}")
            self.logger.error(f"sslscan error: {e}")

    def _parse_sslscan_output(self, sslscan_output: str, result: ScanResult) -> None:
        """Parse sslscan XML output"""
        try:
            # Basic parsing - look for key information
            lines = sslscan_output.split("\n")

            for line in lines:
                # Look for vulnerability indicators
                if "vulnerable" in line.lower():
                    # Extract vulnerability info (simplified)
                    result.add_finding(
                        title="SSLScan Vulnerability Found",
                        description=f"Potential SSL vulnerability: {line.strip()}",
                        severity=ScanSeverity.MEDIUM,
                        category="ssl_vulnerability",
                        source="sslscan",
                        raw_output=line.strip(),
                    )

        except Exception as e:
            result.errors.append(f"sslscan output parsing failed: {str(e)}")
            self.logger.error(f"sslscan parsing error: {e}")

    def _test_ssl_vulnerabilities(
        self, host: str, port: int, result: ScanResult
    ) -> None:
        """
        Test for common SSL/TLS vulnerabilities

        Args:
            host: Target hostname
            port: Target port
            result: ScanResult to populate
        """
        # Test for compression (CRIME vulnerability)
        self._test_compression(host, port, result)

        # Test for renegotiation
        self._test_renegotiation(host, port, result)

    def _test_compression(self, host: str, port: int, result: ScanResult) -> None:
        """Test for SSL compression (CRIME vulnerability)"""
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_TLS)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            with socket.create_connection((host, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    # Check if compression is enabled
                    compression = ssock.compression()

                    if compression:
                        result.add_finding(
                            title="SSL Compression Enabled (CRIME)",
                            description=f"SSL compression is enabled: {compression}",
                            severity=ScanSeverity.MEDIUM,
                            category="ssl_vulnerability",
                            vulnerability="CRIME",
                            compression=compression,
                            recommendation="Disable SSL compression",
                        )

        except Exception as e:
            self.logger.debug(f"Compression test error: {e}")

    def _test_renegotiation(self, host: str, port: int, result: ScanResult) -> None:
        """Test for secure renegotiation"""
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_TLS)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            with socket.create_connection((host, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    # Check for secure renegotiation support
                    # This is simplified - real implementation would be more complex
                    result.add_finding(
                        title="SSL Renegotiation Test",
                        description="SSL renegotiation security tested",
                        severity=ScanSeverity.INFO,
                        category="ssl_configuration",
                        renegotiation_tested=True,
                    )

        except Exception as e:
            self.logger.debug(f"Renegotiation test error: {e}")

    def get_capabilities(self) -> Dict[str, Any]:
        """
        Get scanner capabilities

        Returns:
            Dict: Scanner capabilities and information
        """
        # Check for external tools
        sslscan_available = self.executor.check_tool_exists("sslscan")
        testssl_available = self.executor.check_tool_exists("testssl.sh")

        sslscan_version = (
            self.executor.get_tool_version("sslscan", "--version")
            if sslscan_available
            else None
        )

        return {
            "name": self.name,
            "description": "SSL/TLS certificate and configuration scanner",
            "version": "1.0.0",
            "supported_targets": ["url", "domain", "ip"],
            "scan_types": [
                "certificate_analysis",
                "protocol_testing",
                "cipher_analysis",
                "vulnerability_testing",
                "configuration_check",
            ],
            "timeout": self.timeout,
            "dependencies": {
                "python_ssl": "Python SSL library",
                "sslscan": {
                    "required": False,
                    "version": sslscan_version,
                    "available": sslscan_available,
                },
                "testssl": {"required": False, "available": testssl_available},
                "requests": "Python requests library",
            },
            "options": {
                "port": "Custom SSL port (default: 443)",
                "use_sslscan": "Enable sslscan tool",
                "protocol_tests": "Test specific protocols",
                "vulnerability_tests": "Test for vulnerabilities",
            },
            "features": [
                "Certificate validity checking",
                "Protocol support testing",
                "Cipher suite analysis",
                "Perfect Forward Secrecy testing",
                "HSTS header checking",
                "SSL vulnerability testing",
                "External tool integration",
            ],
        }

    def quick_ssl_scan(self, target: str) -> ScanResult:
        """
        Perform a quick SSL scan (certificate and basic checks)

        Args:
            target: Target URL, domain, or IP

        Returns:
            ScanResult: Scan results
        """
        options = {"use_sslscan": False, "port": 443}
        return self.scan(target, options)

    def full_ssl_scan(self, target: str) -> ScanResult:
        """
        Perform a comprehensive SSL scan (all tests + external tools)

        Args:
            target: Target URL, domain, or IP

        Returns:
            ScanResult: Scan results
        """
        options = {
            "use_sslscan": True,
            "port": 443,
            "protocol_tests": True,
            "vulnerability_tests": True,
        }
        return self.scan(target, options)
